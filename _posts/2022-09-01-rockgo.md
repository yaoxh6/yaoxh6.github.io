---
layout:     post
title:      "rockgo实现思路"
subtitle:   "分布式游戏服务器框架"
date:       2022-09-01 23:36:00
author:     "Yaoxh6"
catalog: true
header-style: text
tags:
  - go
  - rpc
  - ecs
  - 分布式
---

# 前言
最近刚加入了[rockgo](https://github.com/zllangct/rockgo)开源项目,一边阅读源码一边记录。该项目是基于ECS思想,go语言实现的游戏服务端框架。截至今日,master分支实现的功能还不完全基于ECS,并且还有一些要完善。先对master分支现存的代码分析,后续完善代码补充文档。

# 模块
根据example中的SingleNodeWithActor例子分析,该例子比较全面,各个模块均使用到
## conf & launcher
conf作为配置文件,用于指定当前节点是什么角色。具体实现是launcher功能,`	Server = RockGO.DefaultServer()`中的`Server`实际上是`launcherComponent`.
```go
    Server.AddComponentGroup("gate", []ecs.IComponent{g})
    Server.AddComponentGroup("room", []ecs.IComponent{&RoomManagerComponent{}})
    Server.Serve()
```
通过`AddComponentGroup`将组件放在`componentGroup`成员变量中,下面的`Serve`函数名感觉有有点误导,所做的是事情是默认将`NodeComponent`和`ActorProxyComponent`也放在`componentGroup`中。所以`componentGroup`存放的是整个项目所用到的所有的`component`。指定具体某个节点的功能是`AttachGroupsTo`的作用,参数则是作为命令行`SingleNodeWithActor.exe -node node_master`的node参数。
```go
func (this *LauncherComponent) Serve() {
	//添加NodeComponent组件，使对象成为分布式节点
	this.Root().AddComponent(&Cluster.NodeComponent{})

	//添加ActorProxy组件，组织节点间的通信
	this.Root().AddComponent(&Actor.ActorProxyComponent{})

	//添加组件到待选组件列表，默认添加master,child组件
	this.AddComponentGroup("master", []ecs.IComponent{&Cluster.MasterComponent{}})
	this.AddComponentGroup("child", []ecs.IComponent{&Cluster.ChildComponent{}})
	if config.Config.ClusterConfig.IsLocationMode && config.Config.ClusterConfig.Role[0] != "single" {
		this.AddComponentGroup("location", []ecs.IComponent{&Cluster.LocationComponent{}})
	}

	//处理single模式
	if len(config.Config.ClusterConfig.Role) == 0 || config.Config.ClusterConfig.Role[0] == "single" {
		config.Config.ClusterConfig.Role = this.componentGroup.AllGroupsName()
	}

	//添加基础组件组,一般通过组建组的定义决定服务器节点的服务角色
	err := this.componentGroup.AttachGroupsTo(config.Config.ClusterConfig.Role, this.Root())
    ...
}
```
`AttachGroupsTo`会统合普遍情况并且从`componentGroup`选出符合conf的`component`, `attachGroupTo`则是为每一个`componentGroup`创建一个含有该group所有component的Object。所以结果如图是树状结构。
![object](/img/in-post/post-rockgo/object.png)
```go
func (this *ComponentGroups) AttachGroupsTo(groupName []string, target *ecs.Object) error {
    ...
	for _, name := range groupName {
		if g, ok := this.group[name]; ok {
			g.attachGroupTo(target)
		}
        ...
	}
	return nil
}
```

## gate & network
gate是客户端和服务端通信的入口。客户端和服务端通信方式写在network,服务端node之间的通信使用rpc。自定义的服务`TestApi`需要继承`ApiBase`,`ApiBase`再注册`TestApi`的服务,所用的方法大体一致。则是在基类中存一个父类的变量`instance interface{}`,父类在初始化的时候将`instance`设置为自己。
```go
type ApiBase struct {
	//注入子类
	instance interface{}
	protoc   MessageProtocol
	parent   *ecs.Object
	isInit   bool
}

func NewTestApi() *TestApi {
	r := &TestApi{}
	r.Instance(r).SetMT2ID(Testid2mt).SetProtocol(&MessageProtocol.JsonProtocol{})
	return r
}
```
注册的具体过程,在netapi中存两个变量,用户再提供对应协议的对应关系。用于提供的对应关系保存在mt2id中。
```go
var route = map[uint32]*methodType{}
var mt2id = map[reflect.Type]uint32{}

var Testid2mt = map[reflect.Type]uint32{
	reflect.TypeOf(&TestMessage{}):    1,
	reflect.TypeOf(&TestCreateRoom{}): 2,
	reflect.TypeOf(&CreateResult{}):   3,
}
```
在`Init`过程中, 通过`Init`和已经得到的`mt2id`,初始化`route`。这里的用法见附的[通过reflect调用函数](#通过reflect调用函数), 筛选出符合条件的函数,满足条件是传入参数为3个,0是调用者本身,1为session类型,2为导出类型。这样可以`route`得到从`index`到方法的对应关系,方法包含调用者,函数本身,参数类型。
```go
func (this *DefaultGateComponent) Awake(ctx *ecs.Context) {
	...
	this.NetAPI.Init(this.Parent())
	...
}

func (this *ApiBase) Init(parent ...*ecs.Object) {
	...
	this.RegisterGroup(this.instance)
	...
}

func (this *ApiBase) RegisterGroup(api interface{}) {
	this.checkInit()

	typ := reflect.TypeOf(api)

	//检查类型，如果是处理函数，改用 Register
	switch typ.Kind() {
	case reflect.Func:
		this.Register(api)
		return
	}

	logger.Info(fmt.Sprintf("====== start to register API group: [ %s ] ======", typ.Elem().Name()))
	for m := 0; m < typ.NumMethod(); m++ {
		method := typ.Method(m)
		mtype := method.Type
		mname := method.Name
		// Method must be exported.
		if method.PkgPath != "" {
			continue
		}
		numin := mtype.NumIn()
		if numin != 3 {
			continue
		}

		sessType := mtype.In(1)
		if sessType != st {
			continue
		}

		argsType := mtype.In(2)
		if !utils.IsExportedOrBuiltinType(argsType) {
			continue
		}

		if index, ok := mt2id[argsType]; ok {
			if _, exist := route[index]; exist {
				panic(ErrApiRepeated)
			} else {
				route[index] = &methodType{
					resv:     reflect.ValueOf(api),
					method:   method.Func,
					argsType: argsType,
				}
			}
			logger.Info(fmt.Sprintf("Add api: [ %s ], handler: [ %s.%s(*network.Session,*%s) ]", argsType.Elem().Name(), typ.Elem().Name(), mname, argsType.Elem().Name()))
		}
	}
	logger.Info(fmt.Sprintf("======   register API group: [ %s ] end   ======", typ.Elem().Name()))
}
```

服务端服务循环, 取得handle并且监听处理, 这里可以自行扩展协议。
```go
//Serve listen and handle
func (ts *Server) Serve() error {
	h := ts.getHandler()
	if err := h.Listen(); err != nil {
		return err
	}
	return h.Handle()
}

func (ts *Server) getHandler() (sh ServerHandler) {
	if ts.conf.Proto == "tcp" {
		sh = &tcpHandler{conf: ts.conf, ts: ts}
	} else if ts.conf.Proto == "udp" {
		sh = &udpHandler{conf: ts.conf, ts: ts}
	} else if ts.conf.Proto == "ws" {
		sh = &websocketHandler{conf: ts.conf, ts: ts}
	} else {
		panic("unsupport protocol: " + ts.conf.Proto)
	}
	return
}
```
客户端发送协议和服务端注册协议一致,打解包也需要一致。客户端发送格式`包长度-消息ID-消息体`,解包调用取得对应的`消息ID`和`消息体`
```go
	//发送创建房间消息
	{
		var message = "{\"UID\":123456}"
		//此处便宜行事，消息id写死，推荐做法，使用协议对应工具，使用消息结构体
		//本客户端使用websocket，协议类型：4-4-n  包长度-消息ID-消息体
		messageType := uint32(2)
		msg := make([]byte, 4)
		msg = append(msg, []byte(message)...)
		binary.BigEndian.PutUint32(msg[:4], messageType)
	}

	func (h *websocketHandler) recv(sess *Session, conn *websocket.Conn) {
		handler := func(poolCtx []interface{},args ...interface{}) {
			...
			if h.conf.Handler != nil {
				h.conf.Handler(args[0].(*Session), args[1].([]byte))
			} else {
				mid, mes := h.conf.PackageProtocol.ParseMessage(ctx, args[1].([]byte))
				if h.conf.NetAPI != nil && mid != nil {
					h.ts.invoke(ctx, mid[0], mes)
				}
				...
			}
		}
		for !h.ts.isClosed {
			_, pkg, err := conn.ReadMessage()
			...
			// use goroutine pool
			if h.conf.PoolMode {
				var wid int32
				var ok bool
				m,PropertyOk:=sess.GetProperty("workerID")
				if wid,ok=m.(int32);!PropertyOk || !ok{
					wid = WORKER_ID_RANDOM
				}
				h.gpool.AddJobFixed(handler, []interface{}{sess, pkg}, wid)
			} else {
				go handler(nil,sess, pkg)
			}
		}
	}
```
通过`invoke->Route`,再对消息体解包,这样函数和参数类型都可以通过`route`得到,完成函数调用。
```go
func (this *ApiBase) Route(sess *Session, messageID uint32, data []byte) {
	this.checkInit()
	defer utils.CheckError()

	if mt, ok := route[messageID]; ok {
		v := reflect.New(mt.argsType.Elem())
		err := this.protoc.Unmarshal(data, v.Interface())
		if err != nil {
			logger.Debug(fmt.Sprintf("unmarshal message failed :%s ,%s", mt.argsType.Elem().Name(), err))
			return
		}
		args := []reflect.Value{
			mt.resv,
			reflect.ValueOf(sess),
			v,
		}
		mt.method.Call(args)
		return
	}
	...
}
```

## rpc & cluster
此项目的rpc是go自带的rpc,在此基础上做了些封装和修改。采用的是特有gob编码。rpc是cluster内部采用的通信方式。一个`Service`所能提供的服务通过`NodeComponent`的注册功能实现。
```go
func (this *NodeComponent) Register(rcvr interface{}) error {
	return this.rpcServer.Register(rcvr)
}
```
`Server`内部使用`serviceMap sync.Map   // map[string]*service`存储方法名对应方法。这里用的方法和network基本一致,格式稍有差别,1参数要求导出,2参数要求导出,返回值是`error`类型。类似`func (this *MasterService) ReportNodeInfo(args *NodeInfo, reply *bool) error {...}`即可,这样建立函数名与函数的对应关系。
```go
func (server *Server) register(rcvr interface{}, name string, useName bool) error {
	s := new(service)
	s.typ = reflect.TypeOf(rcvr)
	s.rcvr = reflect.ValueOf(rcvr)
	sname := reflect.Indirect(s.rcvr).Type().Name()
	...
	// Install the methods
	s.method = suitableMethods(s.typ, true)
	...
	if _, dup := server.serviceMap.LoadOrStore(sname, s); dup {
		return errors.New("rpc: service already defined: " + sname)
	}
	return nil
}

func suitableMethods(typ reflect.Type, reportErr bool) map[string]*methodType {
	methods := make(map[string]*methodType)
	for m := 0; m < typ.NumMethod(); m++ {
		method := typ.Method(m)
		mtype := method.Type
		mname := method.Name
		// Method must be exported.
		if method.PkgPath != "" {
			continue
		}
		// Method needs three ins: receiver, *args, *reply.
		if mtype.NumIn() < 2 {
			continue
		}
		// First arg need not be a pointer.
		argType := mtype.In(1)
		if !isExportedOrBuiltinType(argType) {
			continue
		}
		numin := mtype.NumIn()

		var replyType reflect.Type
		if numin > 2 {
			// Second arg must be a pointer.
			replyType = mtype.In(2)
			if replyType.Kind() != reflect.Ptr {
				continue
			}
			// reply type must be exported.
			if !isExportedOrBuiltinType(replyType) {
				continue
			}
		} else {
			replyType = nil
		}

		// Method needs one out.
		if mtype.NumOut() != 1 {
			continue
		}
		// The return type of the method must be error.
		if returnType := mtype.Out(0); returnType != typeOfError {
			continue
		}
		methods[mname] = &methodType{method: method, ArgType: argType, ReplyType: replyType}
		logger.Info(fmt.Sprintf("rpc.RegisterGroup: service: [ %s ], method [ %s ] is registed", typ.Elem().Name(), mname))
	}
	return methods
}
```
## ecs
## actor

# 附

## 通过reflect调用函数
通过下面两种方式调用都可以,第一种不用传调用本身,第二种需要。
```go
type Stu struct {
	Name string
}

func (this *Stu) Fn(p1, p2 int) int {
	return p1 + p2
}

func main() {
	s := &Stu{"Hank"}
	valueS := reflect.ValueOf(s)
	method := valueS.MethodByName("Fn")
	paramList := []reflect.Value{
		reflect.ValueOf(22),
		reflect.ValueOf(20),
	}
	resultList := method.Call(paramList)
	fmt.Println(resultList[0].Int()) // 42

	paramList2 := []reflect.Value{
		reflect.ValueOf(s),
		reflect.ValueOf(22),
		reflect.ValueOf(20),
	}

	typ := reflect.TypeOf(s)
	for m := 0; m < typ.NumMethod(); m++ {
		method := typ.Method(m)
		mtype := method.Type
		mname := method.Name
		fmt.Println(mtype, " ", mname)
		fmt.Println(method.Func.Call(paramList2)[0].Int()) // 42
	}
}
```